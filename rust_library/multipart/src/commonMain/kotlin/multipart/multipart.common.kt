// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

@file:Suppress("NAME_SHADOWING")

package multipart

import okio.Buffer
import kotlinx.coroutines.CancellableContinuation
import kotlin.coroutines.resume
import kotlinx.atomicfu.atomic
import kotlinx.atomicfu.getAndUpdate
import kotlinx.atomicfu.locks.reentrantLock
import kotlinx.atomicfu.locks.withLock

// TODO remove suppress when https://youtrack.jetbrains.com/issue/KT-29819/New-rules-for-expect-actual-declarations-in-MPP is solved
@Suppress("NO_ACTUAL_FOR_EXPECT")
expect class Pointer

expect fun kotlin.Long.toPointer(): Pointer

expect fun Pointer.toLong(): kotlin.Long

// TODO remove suppress when https://youtrack.jetbrains.com/issue/KT-29819/New-rules-for-expect-actual-declarations-in-MPP is solved
@Suppress("NO_ACTUAL_FOR_EXPECT")
expect class UBytePointer

expect fun UBytePointer.asSource(len: kotlin.Long): NoCopySource

// TODO remove suppress when https://youtrack.jetbrains.com/issue/KT-29819/New-rules-for-expect-actual-declarations-in-MPP is solved
@Suppress("NO_ACTUAL_FOR_EXPECT")
expect class RustBuffer

// TODO remove suppress when https://youtrack.jetbrains.com/issue/KT-29819/New-rules-for-expect-actual-declarations-in-MPP is solved
@Suppress("NO_ACTUAL_FOR_EXPECT")
expect class RustBufferPointer

expect fun RustBuffer.asSource(): NoCopySource

expect val RustBuffer.dataSize: kotlin.Int

expect fun RustBuffer.free()

expect fun allocRustBuffer(buffer: Buffer): RustBuffer

expect fun RustBufferPointer.setValue(value: RustBuffer)

expect fun emptyRustBuffer(): RustBuffer

interface NoCopySource {
    fun exhausted(): kotlin.Boolean
    fun readByte(): kotlin.Byte
    fun readInt(): kotlin.Int
    fun readLong(): kotlin.Long
    fun readShort(): kotlin.Short
    fun readByteArray(): ByteArray
    fun readByteArray(len: kotlin.Long): ByteArray
}

// This is a helper for safely passing byte references into the rust code.
// It's not actually used at the moment, because there aren't many things that you
// can take a direct pointer to in the JVM, and if we're going to copy something
// then we might as well copy it into a `RustBuffer`. But it's here for API
// completeness.

// TODO remove suppress when https://youtrack.jetbrains.com/issue/KT-29819/New-rules-for-expect-actual-declarations-in-MPP is solved
@Suppress("NO_ACTUAL_FOR_EXPECT")
expect class ForeignBytes
// The FfiConverter interface handles converter types to and from the FFI
//
// All implementing objects should be public to support external types.  When a
// type is external we need to import it's FfiConverter.
interface FfiConverter<KotlinType, FfiType> {

    fun lowerIntoRustBuffer(value: KotlinType): RustBuffer {
        val buffer = Buffer().apply { write(value, buffer) }
        return allocRustBuffer(buffer)
    }

    fun liftFromRustBuffer(rbuf: RustBuffer): KotlinType {
        val byteBuf = rbuf.asSource()
        try {
            val item = read(byteBuf)
            if (!byteBuf.exhausted()) {
                throw RuntimeException("junk remaining in buffer after lifting, something is very wrong!!")
            }
            return item
        } finally {
            rbuf.free()
        }
    }

    fun lift(value: FfiType): KotlinType
    fun lower(value: KotlinType): FfiType
    fun read(source: NoCopySource): KotlinType
    fun allocationSize(value: KotlinType): kotlin.Int
    fun write(value: KotlinType, buf: Buffer)
}

interface FfiConverterRustBuffer<KotlinType> : FfiConverter<KotlinType, RustBuffer> {
    override fun lift(value: RustBuffer) = liftFromRustBuffer(value)
    override fun lower(value: KotlinType) = lowerIntoRustBuffer(value)
}
// A handful of classes and functions to support the generated data structures.
// This would be a good candidate for isolating in its own ffi-support lib.
// Error runtime.

// TODO remove suppress when https://youtrack.jetbrains.com/issue/KT-29819/New-rules-for-expect-actual-declarations-in-MPP is solved
@Suppress("NO_ACTUAL_FOR_EXPECT")
expect class RustCallStatus

internal const val RUST_CALL_STATUS_SUCCESS: kotlin.Byte = 0
internal const val RUST_CALL_STATUS_ERROR: kotlin.Byte = 1
internal const val RUST_CALL_STATUS_PANIC: kotlin.Byte = 2

fun RustCallStatus.isSuccess(): kotlin.Boolean = statusCode == RUST_CALL_STATUS_SUCCESS

fun RustCallStatus.isError(): kotlin.Boolean = statusCode == RUST_CALL_STATUS_ERROR

fun RustCallStatus.isPanic(): kotlin.Boolean = statusCode == RUST_CALL_STATUS_PANIC

expect val RustCallStatus.statusCode: kotlin.Byte

expect val RustCallStatus.errorBuffer: RustBuffer

expect fun <T> withRustCallStatus(block: (RustCallStatus) -> T): T

// TODO remove suppress when https://youtrack.jetbrains.com/issue/KT-29819/New-rules-for-expect-actual-declarations-in-MPP is solved
@Suppress("NO_ACTUAL_FOR_EXPECT")
expect class RustCallStatusByValue

class InternalException(message: kotlin.String) : Exception(message)

// Each top-level error class has a companion object that can lift the error from the call status's rust buffer
interface CallStatusErrorHandler<E> {
    fun lift(errorBuffer: RustBuffer): E;
}

// Helpers for calling Rust
// In practice we usually need to be synchronized to call this safely, so it doesn't
// synchronize itself

// Call a rust function that returns a Result<>.  Pass in the Error class companion that corresponds to the Err
internal inline fun <U, E : Exception> rustCallWithError(
    errorHandler: CallStatusErrorHandler<E>,
    crossinline callback: (RustCallStatus) -> U,
): U =
    withRustCallStatus { status: RustCallStatus ->
        val return_value = callback(status)
        checkCallStatus(errorHandler, status)
        return_value
    }

// Check RustCallStatus and throw an error if the call wasn't successful
internal fun <E : Exception> checkCallStatus(errorHandler: CallStatusErrorHandler<E>, status: RustCallStatus) {
    if (status.isSuccess()) {
        return
    } else if (status.isError()) {
        throw errorHandler.lift(status.errorBuffer)
    } else if (status.isPanic()) {
        // when the rust code sees a panic, it tries to construct a rustbuffer
        // with the message.  but if that code panics, then it just sends back
        // an empty buffer.
        if (status.errorBuffer.dataSize > 0) {
            // TODO avoid additional copy
            throw InternalException(FfiConverterString.lift(status.errorBuffer))
        } else {
            throw InternalException("Rust panic")
        }
    } else {
        throw InternalException("Unknown rust call status: $status.code")
    }
}

// CallStatusErrorHandler implementation for times when we don't expect a CALL_ERROR
object NullCallStatusErrorHandler : CallStatusErrorHandler<InternalException> {
    override fun lift(errorBuffer: RustBuffer): InternalException {
        errorBuffer.free()
        return InternalException("Unexpected CALL_ERROR")
    }
}

// Call a rust function that returns a plain value
internal inline fun <U> rustCall(crossinline callback: (RustCallStatus) -> U): U {
    return rustCallWithError(NullCallStatusErrorHandler, callback);
}

// Map handles to objects
//
// This is used when the Rust code expects an opaque pointer to represent some foreign object.
// Normally we would pass a pointer to the object, but JNA doesn't support getting a pointer from an
// object reference , nor does it support leaking a reference to Rust.
//
// Instead, this class maps ULong values to objects so that we can pass a pointer-sized type to
// Rust when it needs an opaque pointer.
//
// TODO: refactor callbacks to use this class
expect class UniFfiHandleMap<T : Any>() {
    val size: kotlin.Int
    fun insert(obj: T): kotlin.ULong
    fun get(handle: kotlin.ULong): T?
    fun remove(handle: kotlin.ULong): T?
}

// FFI type for Rust future continuations

private val uniffiContinuationHandleMap = UniFfiHandleMap<CancellableContinuation<kotlin.Short>>()

internal fun resumeContinutation(continuationHandle: kotlin.ULong, pollResult: kotlin.Short) {
    uniffiContinuationHandleMap.remove(continuationHandle)?.resume(pollResult)
}

// TODO remove suppress when https://youtrack.jetbrains.com/issue/KT-29819/New-rules-for-expect-actual-declarations-in-MPP is solved
@Suppress("NO_ACTUAL_FOR_EXPECT")
internal expect class UniFfiRustFutureContinuationCallbackType

internal expect fun createUniFfiRustFutureContinuationCallback(): UniFfiRustFutureContinuationCallbackType

// Contains loading, initialization code,
// and the FFI Function declarations.
expect internal object UniFFILib {
    fun uniffi_multipart_fn_init_callback_multipartconsumer(`callbackStub`: ForeignCallback,_uniffi_out_err: RustCallStatus, ): Unit
    fun uniffi_multipart_fn_func_get_boundary(`headers`: RustBuffer,_uniffi_out_err: RustCallStatus, ): RustBuffer
    fun uniffi_multipart_fn_func_process_multipart_close(`id`: Int,_uniffi_out_err: RustCallStatus, ): Unit
    fun uniffi_multipart_fn_func_process_multipart_open(`boundary`: RustBuffer,`consumer`: ULong,_uniffi_out_err: RustCallStatus, ): Unit
    fun uniffi_multipart_fn_func_process_multipart_write(`id`: Int,`chunk`: RustBuffer,_uniffi_out_err: RustCallStatus, ): Unit
    fun ffi_multipart_rustbuffer_alloc(`size`: Int,_uniffi_out_err: RustCallStatus, ): RustBuffer
    fun ffi_multipart_rustbuffer_from_bytes(`bytes`: ForeignBytes,_uniffi_out_err: RustCallStatus, ): RustBuffer
    fun ffi_multipart_rustbuffer_free(`buf`: RustBuffer,_uniffi_out_err: RustCallStatus, ): Unit
    fun ffi_multipart_rustbuffer_reserve(`buf`: RustBuffer,`additional`: Int,_uniffi_out_err: RustCallStatus, ): RustBuffer
    fun ffi_multipart_rust_future_continuation_callback_set(`callback`: UniFfiRustFutureContinuationCallbackType,): Unit
    fun ffi_multipart_rust_future_poll_u8(`handle`: Pointer,`uniffiCallback`: ULong,): Unit
    fun ffi_multipart_rust_future_cancel_u8(`handle`: Pointer,): Unit
    fun ffi_multipart_rust_future_free_u8(`handle`: Pointer,): Unit
    fun ffi_multipart_rust_future_complete_u8(`handle`: Pointer,_uniffi_out_err: RustCallStatus, ): UByte
    fun ffi_multipart_rust_future_poll_i8(`handle`: Pointer,`uniffiCallback`: ULong,): Unit
    fun ffi_multipart_rust_future_cancel_i8(`handle`: Pointer,): Unit
    fun ffi_multipart_rust_future_free_i8(`handle`: Pointer,): Unit
    fun ffi_multipart_rust_future_complete_i8(`handle`: Pointer,_uniffi_out_err: RustCallStatus, ): Byte
    fun ffi_multipart_rust_future_poll_u16(`handle`: Pointer,`uniffiCallback`: ULong,): Unit
    fun ffi_multipart_rust_future_cancel_u16(`handle`: Pointer,): Unit
    fun ffi_multipart_rust_future_free_u16(`handle`: Pointer,): Unit
    fun ffi_multipart_rust_future_complete_u16(`handle`: Pointer,_uniffi_out_err: RustCallStatus, ): UShort
    fun ffi_multipart_rust_future_poll_i16(`handle`: Pointer,`uniffiCallback`: ULong,): Unit
    fun ffi_multipart_rust_future_cancel_i16(`handle`: Pointer,): Unit
    fun ffi_multipart_rust_future_free_i16(`handle`: Pointer,): Unit
    fun ffi_multipart_rust_future_complete_i16(`handle`: Pointer,_uniffi_out_err: RustCallStatus, ): Short
    fun ffi_multipart_rust_future_poll_u32(`handle`: Pointer,`uniffiCallback`: ULong,): Unit
    fun ffi_multipart_rust_future_cancel_u32(`handle`: Pointer,): Unit
    fun ffi_multipart_rust_future_free_u32(`handle`: Pointer,): Unit
    fun ffi_multipart_rust_future_complete_u32(`handle`: Pointer,_uniffi_out_err: RustCallStatus, ): UInt
    fun ffi_multipart_rust_future_poll_i32(`handle`: Pointer,`uniffiCallback`: ULong,): Unit
    fun ffi_multipart_rust_future_cancel_i32(`handle`: Pointer,): Unit
    fun ffi_multipart_rust_future_free_i32(`handle`: Pointer,): Unit
    fun ffi_multipart_rust_future_complete_i32(`handle`: Pointer,_uniffi_out_err: RustCallStatus, ): Int
    fun ffi_multipart_rust_future_poll_u64(`handle`: Pointer,`uniffiCallback`: ULong,): Unit
    fun ffi_multipart_rust_future_cancel_u64(`handle`: Pointer,): Unit
    fun ffi_multipart_rust_future_free_u64(`handle`: Pointer,): Unit
    fun ffi_multipart_rust_future_complete_u64(`handle`: Pointer,_uniffi_out_err: RustCallStatus, ): ULong
    fun ffi_multipart_rust_future_poll_i64(`handle`: Pointer,`uniffiCallback`: ULong,): Unit
    fun ffi_multipart_rust_future_cancel_i64(`handle`: Pointer,): Unit
    fun ffi_multipart_rust_future_free_i64(`handle`: Pointer,): Unit
    fun ffi_multipart_rust_future_complete_i64(`handle`: Pointer,_uniffi_out_err: RustCallStatus, ): Long
    fun ffi_multipart_rust_future_poll_f32(`handle`: Pointer,`uniffiCallback`: ULong,): Unit
    fun ffi_multipart_rust_future_cancel_f32(`handle`: Pointer,): Unit
    fun ffi_multipart_rust_future_free_f32(`handle`: Pointer,): Unit
    fun ffi_multipart_rust_future_complete_f32(`handle`: Pointer,_uniffi_out_err: RustCallStatus, ): Float
    fun ffi_multipart_rust_future_poll_f64(`handle`: Pointer,`uniffiCallback`: ULong,): Unit
    fun ffi_multipart_rust_future_cancel_f64(`handle`: Pointer,): Unit
    fun ffi_multipart_rust_future_free_f64(`handle`: Pointer,): Unit
    fun ffi_multipart_rust_future_complete_f64(`handle`: Pointer,_uniffi_out_err: RustCallStatus, ): Double
    fun ffi_multipart_rust_future_poll_pointer(`handle`: Pointer,`uniffiCallback`: ULong,): Unit
    fun ffi_multipart_rust_future_cancel_pointer(`handle`: Pointer,): Unit
    fun ffi_multipart_rust_future_free_pointer(`handle`: Pointer,): Unit
    fun ffi_multipart_rust_future_complete_pointer(`handle`: Pointer,_uniffi_out_err: RustCallStatus, ): Pointer
    fun ffi_multipart_rust_future_poll_rust_buffer(`handle`: Pointer,`uniffiCallback`: ULong,): Unit
    fun ffi_multipart_rust_future_cancel_rust_buffer(`handle`: Pointer,): Unit
    fun ffi_multipart_rust_future_free_rust_buffer(`handle`: Pointer,): Unit
    fun ffi_multipart_rust_future_complete_rust_buffer(`handle`: Pointer,_uniffi_out_err: RustCallStatus, ): RustBuffer
    fun ffi_multipart_rust_future_poll_void(`handle`: Pointer,`uniffiCallback`: ULong,): Unit
    fun ffi_multipart_rust_future_cancel_void(`handle`: Pointer,): Unit
    fun ffi_multipart_rust_future_free_void(`handle`: Pointer,): Unit
    fun ffi_multipart_rust_future_complete_void(`handle`: Pointer,_uniffi_out_err: RustCallStatus, ): Unit
    fun uniffi_multipart_checksum_func_get_boundary(): UShort
    fun uniffi_multipart_checksum_func_process_multipart_close(): UShort
    fun uniffi_multipart_checksum_func_process_multipart_open(): UShort
    fun uniffi_multipart_checksum_func_process_multipart_write(): UShort
    fun uniffi_multipart_checksum_method_multipartconsumer_on_open(): UShort
    fun uniffi_multipart_checksum_method_multipartconsumer_on_field_start(): UShort
    fun uniffi_multipart_checksum_method_multipartconsumer_on_field_chunk(): UShort
    fun uniffi_multipart_checksum_method_multipartconsumer_on_field_end(): UShort
    fun uniffi_multipart_checksum_method_multipartconsumer_on_close(): UShort
    fun ffi_multipart_uniffi_contract_version(): UInt
    
}

// Async support

// Public interface members begin here.


object FfiConverterInt : FfiConverter<kotlin.Int, kotlin.Int> {
    override fun lift(value: kotlin.Int): kotlin.Int = value

    override fun read(source: NoCopySource): kotlin.Int = source.readInt()

    override fun lower(value: kotlin.Int): kotlin.Int = value

    override fun allocationSize(value: kotlin.Int) = 4

    override fun write(value: kotlin.Int, buf: Buffer) {
        buf.writeInt(value)
    }
}

object FfiConverterString : FfiConverter<kotlin.String, RustBuffer> {
    override fun lift(value: RustBuffer): kotlin.String {
        try {
            val byteArr = value.asSource().readByteArray(value.dataSize.toLong())
            return byteArr.decodeToString()
        } finally {
            value.free()
        }
    }

    override fun read(source: NoCopySource): kotlin.String {
        val len = source.readInt()
        val byteArr = source.readByteArray(len.toLong())
        return byteArr.decodeToString()
    }

    override fun lower(value: kotlin.String): RustBuffer {
        val buffer = Buffer().write(value.encodeToByteArray())
        return allocRustBuffer(buffer)
    }

    override fun allocationSize(value: kotlin.String): kotlin.Int {
        val sizeForLength = 4
        val sizeForString = value.length * 3
        return sizeForLength + sizeForString
    }

    override fun write(value: kotlin.String, buf: Buffer) {
        val byteArr = value.encodeToByteArray()
        buf.writeInt(byteArr.size)
        buf.write(byteArr)
    }
}

internal object FfiConverterByteArray: FfiConverterRustBuffer<ByteArray> {
    override fun read(buf: NoCopySource): ByteArray {
        val len = buf.readInt()
        return buf.readByteArray(len.toLong())
    }
    override fun allocationSize(value: ByteArray): Int {
        return 4 + value.size
    }
    override fun write(value: ByteArray, buf: Buffer) {
        buf.writeInt(value.size)
        buf.write(value)
    }
}






typealias Handle = kotlin.ULong
internal class ConcurrentHandleMap<T>(
    private val leftMap: MutableMap<Handle, T> = mutableMapOf(),
    private val rightMap: MutableMap<T, Handle> = mutableMapOf()
) {
    private val lock = reentrantLock()
    private val currentHandle = atomic(0L)

    fun insert(obj: T): Handle =
        lock.withLock {
            rightMap[obj] ?: currentHandle.getAndIncrement()
                .let { it.toULong() }
                .also { handle ->
                    leftMap[handle] = obj
                    rightMap[obj] = handle
                }
        }

    fun get(handle: Handle) = lock.withLock {
        leftMap[handle]
    }

    fun delete(handle: Handle) {
        this.remove(handle)
    }

    fun remove(handle: Handle): T? =
        lock.withLock {
            leftMap.remove(handle)?.let { obj ->
                rightMap.remove(obj)
                obj
            }
        }
}

// TODO remove suppress when https://youtrack.jetbrains.com/issue/KT-29819/New-rules-for-expect-actual-declarations-in-MPP is solved
@Suppress("NO_ACTUAL_FOR_EXPECT")
expect class ForeignCallback

// Magic number for the Rust proxy to call using the same mechanism as every other method,
// to free the callback once it's dropped by Rust.
internal const val IDX_CALLBACK_FREE = 0

// Callback return codes
internal const val UNIFFI_CALLBACK_SUCCESS = 0
internal const val UNIFFI_CALLBACK_ERROR = 1
internal const val UNIFFI_CALLBACK_UNEXPECTED_ERROR = 2

abstract class FfiConverterCallbackInterface<CallbackInterface> : FfiConverter<CallbackInterface, Handle> {
    private val handleMap = ConcurrentHandleMap<CallbackInterface>()

    // Registers the foreign callback with the Rust side.
    // This method is generated for each callback interface.
    internal abstract fun register(lib: UniFFILib)

    fun drop(handle: Handle) {
        handleMap.remove(handle)
    }

    override fun lift(value: Handle): CallbackInterface {
        return handleMap.get(value) ?: throw InternalException("No callback in handlemap; this is a Uniffi bug")
    }

    override fun read(source: NoCopySource) = lift(source.readLong().toULong())

    override fun lower(value: CallbackInterface) =
        handleMap.insert(value).also {
            check(handleMap.get(it) === value) { "Handle map is not returning the object we just placed there. This is a bug in the HandleMap." }
        }

    override fun allocationSize(value: CallbackInterface) = 8

    override fun write(value: CallbackInterface, buf: Buffer) {
        buf.writeLong(lower(value).toLong())
    }
}

object ForeignCallbackMultipartConsumer {
    @Suppress("TooGenericExceptionCaught")
    fun invoke(handle: Handle, method: kotlin.Int, argsData: UBytePointer, argsLen: kotlin.Int, outBuf: RustBufferPointer): kotlin.Int {
        val cb = FfiConverterTypeMultipartConsumer.lift(handle)
        return when (method) {
            IDX_CALLBACK_FREE -> {
                FfiConverterTypeMultipartConsumer.drop(handle)
                UNIFFI_CALLBACK_SUCCESS
            }
            1 -> {
                try {
                    val buffer = this.`invokeOnOpen`(cb, argsData, argsLen)
                    // Success
                    outBuf.setValue(buffer)
                    UNIFFI_CALLBACK_SUCCESS
                } catch (e: Throwable) {
                    try {
                        outBuf.setValue(FfiConverterString.lower(e.toString()))
                    } catch (e: Throwable) {
                    }
                    UNIFFI_CALLBACK_UNEXPECTED_ERROR
                }
            }
            2 -> {
                try {
                    val buffer = this.`invokeOnFieldStart`(cb, argsData, argsLen)
                    // Success
                    outBuf.setValue(buffer)
                    UNIFFI_CALLBACK_SUCCESS
                } catch (e: Throwable) {
                    try {
                        outBuf.setValue(FfiConverterString.lower(e.toString()))
                    } catch (e: Throwable) {
                    }
                    UNIFFI_CALLBACK_UNEXPECTED_ERROR
                }
            }
            3 -> {
                try {
                    val buffer = this.`invokeOnFieldChunk`(cb, argsData, argsLen)
                    // Success
                    outBuf.setValue(buffer)
                    UNIFFI_CALLBACK_SUCCESS
                } catch (e: Throwable) {
                    try {
                        outBuf.setValue(FfiConverterString.lower(e.toString()))
                    } catch (e: Throwable) {
                    }
                    UNIFFI_CALLBACK_UNEXPECTED_ERROR
                }
            }
            4 -> {
                try {
                    val buffer = this.`invokeOnFieldEnd`(cb, argsData, argsLen)
                    // Success
                    outBuf.setValue(buffer)
                    UNIFFI_CALLBACK_SUCCESS
                } catch (e: Throwable) {
                    try {
                        outBuf.setValue(FfiConverterString.lower(e.toString()))
                    } catch (e: Throwable) {
                    }
                    UNIFFI_CALLBACK_UNEXPECTED_ERROR
                }
            }
            5 -> {
                try {
                    val buffer = this.`invokeOnClose`(cb, argsData, argsLen)
                    // Success
                    outBuf.setValue(buffer)
                    UNIFFI_CALLBACK_SUCCESS
                } catch (e: Throwable) {
                    try {
                        outBuf.setValue(FfiConverterString.lower(e.toString()))
                    } catch (e: Throwable) {
                    }
                    UNIFFI_CALLBACK_UNEXPECTED_ERROR
                }
            }
            
            else -> {
                try {
                    outBuf.setValue(FfiConverterString.lower("Invalid Callback index"))
                } catch (e: Throwable) {
                }
                UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        }
    }

    
    private fun `invokeOnOpen`(kotlinCallbackInterface: MultipartConsumer, argsData: UBytePointer, argsLen: kotlin.Int): RustBuffer {
        val source = argsData.asSource(argsLen.toLong())
        return kotlinCallbackInterface.`onOpen`(
            FfiConverterInt.read(source)
            )
        .let { emptyRustBuffer() }
            }
    
    private fun `invokeOnFieldStart`(kotlinCallbackInterface: MultipartConsumer, argsData: UBytePointer, argsLen: kotlin.Int): RustBuffer {
        val source = argsData.asSource(argsLen.toLong())
        return kotlinCallbackInterface.`onFieldStart`(
            FfiConverterOptionalString.read(source), 
            FfiConverterOptionalString.read(source), 
            FfiConverterOptionalString.read(source), 
            FfiConverterInt.read(source)
            )
        .let { emptyRustBuffer() }
            }
    
    private fun `invokeOnFieldChunk`(kotlinCallbackInterface: MultipartConsumer, argsData: UBytePointer, argsLen: kotlin.Int): RustBuffer {
        val source = argsData.asSource(argsLen.toLong())
        return kotlinCallbackInterface.`onFieldChunk`(
            FfiConverterInt.read(source), 
            FfiConverterByteArray.read(source)
            )
        .let { emptyRustBuffer() }
            }
    
    private fun `invokeOnFieldEnd`(kotlinCallbackInterface: MultipartConsumer, argsData: UBytePointer, argsLen: kotlin.Int): RustBuffer {
        val source = argsData.asSource(argsLen.toLong())
        return kotlinCallbackInterface.`onFieldEnd`(
            FfiConverterInt.read(source)
            )
        .let { emptyRustBuffer() }
            }
    
    private fun `invokeOnClose`(kotlinCallbackInterface: MultipartConsumer, argsData: UBytePointer, argsLen: kotlin.Int): RustBuffer {
        val source = argsData.asSource(argsLen.toLong())
        return kotlinCallbackInterface.`onClose`(
            FfiConverterInt.read(source)
            )
        .let { emptyRustBuffer() }
            }
    
}

interface MultipartConsumer {
    fun `onOpen`(`id`: kotlin.Int)
    fun `onFieldStart`(`name`: kotlin.String?, `fileName`: kotlin.String?, `contentType`: kotlin.String?, `fieldIndex`: kotlin.Int)
    fun `onFieldChunk`(`fieldIndex`: kotlin.Int, `chunk`: kotlin.ByteArray)
    fun `onFieldEnd`(`fieldIndex`: kotlin.Int)
    fun `onClose`(`id`: kotlin.Int)
    
}

object FfiConverterTypeMultipartConsumer: FfiConverterCallbackInterface<MultipartConsumer>() {
    // prevent the callback from being GC'ed
    private val foreignCallback = ForeignCallbackMultipartConsumer.toForeignCallback()

    override fun register(lib: UniFFILib) {
        rustCall { status ->
            lib.uniffi_multipart_fn_init_callback_multipartconsumer(foreignCallback, status)
        }
    }
}

expect fun ForeignCallbackMultipartConsumer.toForeignCallback() : ForeignCallback




object FfiConverterOptionalString: FfiConverterRustBuffer<kotlin.String?> {
    override fun read(source: NoCopySource): kotlin.String? {
        if (source.readByte().toInt() == 0) {
            return null
        }
        return FfiConverterString.read(source)
    }

    override fun allocationSize(value: kotlin.String?): kotlin.Int {
        if (value == null) {
            return 1
        } else {
            return 1 + FfiConverterString.allocationSize(value)
        }
    }

    override fun write(value: kotlin.String?, buf: Buffer) {
        if (value == null) {
            buf.writeByte(0)
        } else {
            buf.writeByte(1)
            FfiConverterString.write(value, buf)
        }
    }
}



object FfiConverterMapStringString: FfiConverterRustBuffer<Map<kotlin.String, kotlin.String>> {
    override fun read(source: NoCopySource): Map<kotlin.String, kotlin.String> {
        val items : MutableMap<kotlin.String, kotlin.String> = mutableMapOf()
        val len = source.readInt()
        repeat(len) {
            val k = FfiConverterString.read(source)
            val v = FfiConverterString.read(source)
            items[k] = v
        }
        return items
    }

    override fun allocationSize(value: Map<kotlin.String, kotlin.String>): kotlin.Int {
        val spaceForMapSize = 4
        val spaceForChildren = value.map { (k, v) ->
            FfiConverterString.allocationSize(k) +
            FfiConverterString.allocationSize(v)
        }.sum()
        return spaceForMapSize + spaceForChildren
    }

    override fun write(value: Map<kotlin.String, kotlin.String>, buf: Buffer) {
        buf.writeInt(value.size)
        value.forEach { (k, v) ->
            FfiConverterString.write(k, buf)
            FfiConverterString.write(v, buf)
        }
    }
} 

fun `getBoundary`(`headers`: Map<kotlin.String, kotlin.String>): kotlin.String? {
    return FfiConverterOptionalString.lift(
    rustCall { _status: RustCallStatus ->
    UniFFILib.uniffi_multipart_fn_func_get_boundary(FfiConverterMapStringString.lower(`headers`), _status)
})
}

 

fun `processMultipartClose`(`id`: kotlin.Int) =
    
    rustCall { _status: RustCallStatus ->
    UniFFILib.uniffi_multipart_fn_func_process_multipart_close(FfiConverterInt.lower(`id`), _status)
}
 

fun `processMultipartOpen`(`boundary`: kotlin.String, `consumer`: MultipartConsumer) =
    
    rustCall { _status: RustCallStatus ->
    UniFFILib.uniffi_multipart_fn_func_process_multipart_open(FfiConverterString.lower(`boundary`), FfiConverterTypeMultipartConsumer.lower(`consumer`), _status)
}
 

fun `processMultipartWrite`(`id`: kotlin.Int, `chunk`: kotlin.ByteArray) =
    
    rustCall { _status: RustCallStatus ->
    UniFFILib.uniffi_multipart_fn_func_process_multipart_write(FfiConverterInt.lower(`id`), FfiConverterByteArray.lower(`chunk`), _status)
}


