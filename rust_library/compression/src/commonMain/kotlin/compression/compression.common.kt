// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

@file:Suppress("NAME_SHADOWING")

package compression

import okio.Buffer
import kotlinx.coroutines.CancellableContinuation
import kotlin.coroutines.resume

// TODO remove suppress when https://youtrack.jetbrains.com/issue/KT-29819/New-rules-for-expect-actual-declarations-in-MPP is solved
@Suppress("NO_ACTUAL_FOR_EXPECT")
expect class Pointer

expect fun kotlin.Long.toPointer(): Pointer

expect fun Pointer.toLong(): kotlin.Long

// TODO remove suppress when https://youtrack.jetbrains.com/issue/KT-29819/New-rules-for-expect-actual-declarations-in-MPP is solved
@Suppress("NO_ACTUAL_FOR_EXPECT")
expect class UBytePointer

expect fun UBytePointer.asSource(len: kotlin.Long): NoCopySource

// TODO remove suppress when https://youtrack.jetbrains.com/issue/KT-29819/New-rules-for-expect-actual-declarations-in-MPP is solved
@Suppress("NO_ACTUAL_FOR_EXPECT")
expect class RustBuffer

// TODO remove suppress when https://youtrack.jetbrains.com/issue/KT-29819/New-rules-for-expect-actual-declarations-in-MPP is solved
@Suppress("NO_ACTUAL_FOR_EXPECT")
expect class RustBufferPointer

expect fun RustBuffer.asSource(): NoCopySource

expect val RustBuffer.dataSize: kotlin.Int

expect fun RustBuffer.free()

expect fun allocRustBuffer(buffer: Buffer): RustBuffer

expect fun RustBufferPointer.setValue(value: RustBuffer)

expect fun emptyRustBuffer(): RustBuffer

interface NoCopySource {
    fun exhausted(): kotlin.Boolean
    fun readByte(): kotlin.Byte
    fun readInt(): kotlin.Int
    fun readLong(): kotlin.Long
    fun readShort(): kotlin.Short
    fun readByteArray(): ByteArray
    fun readByteArray(len: kotlin.Long): ByteArray
}

// This is a helper for safely passing byte references into the rust code.
// It's not actually used at the moment, because there aren't many things that you
// can take a direct pointer to in the JVM, and if we're going to copy something
// then we might as well copy it into a `RustBuffer`. But it's here for API
// completeness.

// TODO remove suppress when https://youtrack.jetbrains.com/issue/KT-29819/New-rules-for-expect-actual-declarations-in-MPP is solved
@Suppress("NO_ACTUAL_FOR_EXPECT")
expect class ForeignBytes
// The FfiConverter interface handles converter types to and from the FFI
//
// All implementing objects should be public to support external types.  When a
// type is external we need to import it's FfiConverter.
interface FfiConverter<KotlinType, FfiType> {

    fun lowerIntoRustBuffer(value: KotlinType): RustBuffer {
        val buffer = Buffer().apply { write(value, buffer) }
        return allocRustBuffer(buffer)
    }

    fun liftFromRustBuffer(rbuf: RustBuffer): KotlinType {
        val byteBuf = rbuf.asSource()
        try {
            val item = read(byteBuf)
            if (!byteBuf.exhausted()) {
                throw RuntimeException("junk remaining in buffer after lifting, something is very wrong!!")
            }
            return item
        } finally {
            rbuf.free()
        }
    }

    fun lift(value: FfiType): KotlinType
    fun lower(value: KotlinType): FfiType
    fun read(source: NoCopySource): KotlinType
    fun allocationSize(value: KotlinType): kotlin.Int
    fun write(value: KotlinType, buf: Buffer)
}

interface FfiConverterRustBuffer<KotlinType> : FfiConverter<KotlinType, RustBuffer> {
    override fun lift(value: RustBuffer) = liftFromRustBuffer(value)
    override fun lower(value: KotlinType) = lowerIntoRustBuffer(value)
}
// A handful of classes and functions to support the generated data structures.
// This would be a good candidate for isolating in its own ffi-support lib.
// Error runtime.

// TODO remove suppress when https://youtrack.jetbrains.com/issue/KT-29819/New-rules-for-expect-actual-declarations-in-MPP is solved
@Suppress("NO_ACTUAL_FOR_EXPECT")
expect class RustCallStatus

internal const val RUST_CALL_STATUS_SUCCESS: kotlin.Byte = 0
internal const val RUST_CALL_STATUS_ERROR: kotlin.Byte = 1
internal const val RUST_CALL_STATUS_PANIC: kotlin.Byte = 2

fun RustCallStatus.isSuccess(): kotlin.Boolean = statusCode == RUST_CALL_STATUS_SUCCESS

fun RustCallStatus.isError(): kotlin.Boolean = statusCode == RUST_CALL_STATUS_ERROR

fun RustCallStatus.isPanic(): kotlin.Boolean = statusCode == RUST_CALL_STATUS_PANIC

expect val RustCallStatus.statusCode: kotlin.Byte

expect val RustCallStatus.errorBuffer: RustBuffer

expect fun <T> withRustCallStatus(block: (RustCallStatus) -> T): T

// TODO remove suppress when https://youtrack.jetbrains.com/issue/KT-29819/New-rules-for-expect-actual-declarations-in-MPP is solved
@Suppress("NO_ACTUAL_FOR_EXPECT")
expect class RustCallStatusByValue

class InternalException(message: kotlin.String) : Exception(message)

// Each top-level error class has a companion object that can lift the error from the call status's rust buffer
interface CallStatusErrorHandler<E> {
    fun lift(errorBuffer: RustBuffer): E;
}

// Helpers for calling Rust
// In practice we usually need to be synchronized to call this safely, so it doesn't
// synchronize itself

// Call a rust function that returns a Result<>.  Pass in the Error class companion that corresponds to the Err
internal inline fun <U, E : Exception> rustCallWithError(
    errorHandler: CallStatusErrorHandler<E>,
    crossinline callback: (RustCallStatus) -> U,
): U =
    withRustCallStatus { status: RustCallStatus ->
        val return_value = callback(status)
        checkCallStatus(errorHandler, status)
        return_value
    }

// Check RustCallStatus and throw an error if the call wasn't successful
internal fun <E : Exception> checkCallStatus(errorHandler: CallStatusErrorHandler<E>, status: RustCallStatus) {
    if (status.isSuccess()) {
        return
    } else if (status.isError()) {
        throw errorHandler.lift(status.errorBuffer)
    } else if (status.isPanic()) {
        // when the rust code sees a panic, it tries to construct a rustbuffer
        // with the message.  but if that code panics, then it just sends back
        // an empty buffer.
        if (status.errorBuffer.dataSize > 0) {
            // TODO avoid additional copy
            throw InternalException(FfiConverterString.lift(status.errorBuffer))
        } else {
            throw InternalException("Rust panic")
        }
    } else {
        throw InternalException("Unknown rust call status: $status.code")
    }
}

// CallStatusErrorHandler implementation for times when we don't expect a CALL_ERROR
object NullCallStatusErrorHandler : CallStatusErrorHandler<InternalException> {
    override fun lift(errorBuffer: RustBuffer): InternalException {
        errorBuffer.free()
        return InternalException("Unexpected CALL_ERROR")
    }
}

// Call a rust function that returns a plain value
internal inline fun <U> rustCall(crossinline callback: (RustCallStatus) -> U): U {
    return rustCallWithError(NullCallStatusErrorHandler, callback);
}

// Map handles to objects
//
// This is used when the Rust code expects an opaque pointer to represent some foreign object.
// Normally we would pass a pointer to the object, but JNA doesn't support getting a pointer from an
// object reference , nor does it support leaking a reference to Rust.
//
// Instead, this class maps ULong values to objects so that we can pass a pointer-sized type to
// Rust when it needs an opaque pointer.
//
// TODO: refactor callbacks to use this class
expect class UniFfiHandleMap<T : Any>() {
    val size: kotlin.Int
    fun insert(obj: T): kotlin.ULong
    fun get(handle: kotlin.ULong): T?
    fun remove(handle: kotlin.ULong): T?
}

// FFI type for Rust future continuations

private val uniffiContinuationHandleMap = UniFfiHandleMap<CancellableContinuation<kotlin.Short>>()

internal fun resumeContinutation(continuationHandle: kotlin.ULong, pollResult: kotlin.Short) {
    uniffiContinuationHandleMap.remove(continuationHandle)?.resume(pollResult)
}

// TODO remove suppress when https://youtrack.jetbrains.com/issue/KT-29819/New-rules-for-expect-actual-declarations-in-MPP is solved
@Suppress("NO_ACTUAL_FOR_EXPECT")
internal expect class UniFfiRustFutureContinuationCallbackType

internal expect fun createUniFfiRustFutureContinuationCallback(): UniFfiRustFutureContinuationCallbackType

// Contains loading, initialization code,
// and the FFI Function declarations.
expect internal object UniFFILib {
    fun uniffi_compression_fn_func_zstd_compress(`data`: RustBuffer,`level`: Int,_uniffi_out_err: RustCallStatus, ): RustBuffer
    fun uniffi_compression_fn_func_zstd_decompress(`data`: RustBuffer,_uniffi_out_err: RustCallStatus, ): RustBuffer
    fun ffi_compression_rustbuffer_alloc(`size`: Int,_uniffi_out_err: RustCallStatus, ): RustBuffer
    fun ffi_compression_rustbuffer_from_bytes(`bytes`: ForeignBytes,_uniffi_out_err: RustCallStatus, ): RustBuffer
    fun ffi_compression_rustbuffer_free(`buf`: RustBuffer,_uniffi_out_err: RustCallStatus, ): Unit
    fun ffi_compression_rustbuffer_reserve(`buf`: RustBuffer,`additional`: Int,_uniffi_out_err: RustCallStatus, ): RustBuffer
    fun ffi_compression_rust_future_continuation_callback_set(`callback`: UniFfiRustFutureContinuationCallbackType,): Unit
    fun ffi_compression_rust_future_poll_u8(`handle`: Pointer,`uniffiCallback`: ULong,): Unit
    fun ffi_compression_rust_future_cancel_u8(`handle`: Pointer,): Unit
    fun ffi_compression_rust_future_free_u8(`handle`: Pointer,): Unit
    fun ffi_compression_rust_future_complete_u8(`handle`: Pointer,_uniffi_out_err: RustCallStatus, ): UByte
    fun ffi_compression_rust_future_poll_i8(`handle`: Pointer,`uniffiCallback`: ULong,): Unit
    fun ffi_compression_rust_future_cancel_i8(`handle`: Pointer,): Unit
    fun ffi_compression_rust_future_free_i8(`handle`: Pointer,): Unit
    fun ffi_compression_rust_future_complete_i8(`handle`: Pointer,_uniffi_out_err: RustCallStatus, ): Byte
    fun ffi_compression_rust_future_poll_u16(`handle`: Pointer,`uniffiCallback`: ULong,): Unit
    fun ffi_compression_rust_future_cancel_u16(`handle`: Pointer,): Unit
    fun ffi_compression_rust_future_free_u16(`handle`: Pointer,): Unit
    fun ffi_compression_rust_future_complete_u16(`handle`: Pointer,_uniffi_out_err: RustCallStatus, ): UShort
    fun ffi_compression_rust_future_poll_i16(`handle`: Pointer,`uniffiCallback`: ULong,): Unit
    fun ffi_compression_rust_future_cancel_i16(`handle`: Pointer,): Unit
    fun ffi_compression_rust_future_free_i16(`handle`: Pointer,): Unit
    fun ffi_compression_rust_future_complete_i16(`handle`: Pointer,_uniffi_out_err: RustCallStatus, ): Short
    fun ffi_compression_rust_future_poll_u32(`handle`: Pointer,`uniffiCallback`: ULong,): Unit
    fun ffi_compression_rust_future_cancel_u32(`handle`: Pointer,): Unit
    fun ffi_compression_rust_future_free_u32(`handle`: Pointer,): Unit
    fun ffi_compression_rust_future_complete_u32(`handle`: Pointer,_uniffi_out_err: RustCallStatus, ): UInt
    fun ffi_compression_rust_future_poll_i32(`handle`: Pointer,`uniffiCallback`: ULong,): Unit
    fun ffi_compression_rust_future_cancel_i32(`handle`: Pointer,): Unit
    fun ffi_compression_rust_future_free_i32(`handle`: Pointer,): Unit
    fun ffi_compression_rust_future_complete_i32(`handle`: Pointer,_uniffi_out_err: RustCallStatus, ): Int
    fun ffi_compression_rust_future_poll_u64(`handle`: Pointer,`uniffiCallback`: ULong,): Unit
    fun ffi_compression_rust_future_cancel_u64(`handle`: Pointer,): Unit
    fun ffi_compression_rust_future_free_u64(`handle`: Pointer,): Unit
    fun ffi_compression_rust_future_complete_u64(`handle`: Pointer,_uniffi_out_err: RustCallStatus, ): ULong
    fun ffi_compression_rust_future_poll_i64(`handle`: Pointer,`uniffiCallback`: ULong,): Unit
    fun ffi_compression_rust_future_cancel_i64(`handle`: Pointer,): Unit
    fun ffi_compression_rust_future_free_i64(`handle`: Pointer,): Unit
    fun ffi_compression_rust_future_complete_i64(`handle`: Pointer,_uniffi_out_err: RustCallStatus, ): Long
    fun ffi_compression_rust_future_poll_f32(`handle`: Pointer,`uniffiCallback`: ULong,): Unit
    fun ffi_compression_rust_future_cancel_f32(`handle`: Pointer,): Unit
    fun ffi_compression_rust_future_free_f32(`handle`: Pointer,): Unit
    fun ffi_compression_rust_future_complete_f32(`handle`: Pointer,_uniffi_out_err: RustCallStatus, ): Float
    fun ffi_compression_rust_future_poll_f64(`handle`: Pointer,`uniffiCallback`: ULong,): Unit
    fun ffi_compression_rust_future_cancel_f64(`handle`: Pointer,): Unit
    fun ffi_compression_rust_future_free_f64(`handle`: Pointer,): Unit
    fun ffi_compression_rust_future_complete_f64(`handle`: Pointer,_uniffi_out_err: RustCallStatus, ): Double
    fun ffi_compression_rust_future_poll_pointer(`handle`: Pointer,`uniffiCallback`: ULong,): Unit
    fun ffi_compression_rust_future_cancel_pointer(`handle`: Pointer,): Unit
    fun ffi_compression_rust_future_free_pointer(`handle`: Pointer,): Unit
    fun ffi_compression_rust_future_complete_pointer(`handle`: Pointer,_uniffi_out_err: RustCallStatus, ): Pointer
    fun ffi_compression_rust_future_poll_rust_buffer(`handle`: Pointer,`uniffiCallback`: ULong,): Unit
    fun ffi_compression_rust_future_cancel_rust_buffer(`handle`: Pointer,): Unit
    fun ffi_compression_rust_future_free_rust_buffer(`handle`: Pointer,): Unit
    fun ffi_compression_rust_future_complete_rust_buffer(`handle`: Pointer,_uniffi_out_err: RustCallStatus, ): RustBuffer
    fun ffi_compression_rust_future_poll_void(`handle`: Pointer,`uniffiCallback`: ULong,): Unit
    fun ffi_compression_rust_future_cancel_void(`handle`: Pointer,): Unit
    fun ffi_compression_rust_future_free_void(`handle`: Pointer,): Unit
    fun ffi_compression_rust_future_complete_void(`handle`: Pointer,_uniffi_out_err: RustCallStatus, ): Unit
    fun uniffi_compression_checksum_func_zstd_compress(): UShort
    fun uniffi_compression_checksum_func_zstd_decompress(): UShort
    fun ffi_compression_uniffi_contract_version(): UInt
    
}

// Async support

// Public interface members begin here.


object FfiConverterInt : FfiConverter<kotlin.Int, kotlin.Int> {
    override fun lift(value: kotlin.Int): kotlin.Int = value

    override fun read(source: NoCopySource): kotlin.Int = source.readInt()

    override fun lower(value: kotlin.Int): kotlin.Int = value

    override fun allocationSize(value: kotlin.Int) = 4

    override fun write(value: kotlin.Int, buf: Buffer) {
        buf.writeInt(value)
    }
}

object FfiConverterString : FfiConverter<kotlin.String, RustBuffer> {
    override fun lift(value: RustBuffer): kotlin.String {
        try {
            val byteArr = value.asSource().readByteArray(value.dataSize.toLong())
            return byteArr.decodeToString()
        } finally {
            value.free()
        }
    }

    override fun read(source: NoCopySource): kotlin.String {
        val len = source.readInt()
        val byteArr = source.readByteArray(len.toLong())
        return byteArr.decodeToString()
    }

    override fun lower(value: kotlin.String): RustBuffer {
        val buffer = Buffer().write(value.encodeToByteArray())
        return allocRustBuffer(buffer)
    }

    override fun allocationSize(value: kotlin.String): kotlin.Int {
        val sizeForLength = 4
        val sizeForString = value.length * 3
        return sizeForLength + sizeForString
    }

    override fun write(value: kotlin.String, buf: Buffer) {
        val byteArr = value.encodeToByteArray()
        buf.writeInt(byteArr.size)
        buf.write(byteArr)
    }
}

internal object FfiConverterByteArray: FfiConverterRustBuffer<ByteArray> {
    override fun read(buf: NoCopySource): ByteArray {
        val len = buf.readInt()
        return buf.readByteArray(len.toLong())
    }
    override fun allocationSize(value: ByteArray): Int {
        return 4 + value.size
    }
    override fun write(value: ByteArray, buf: Buffer) {
        buf.writeInt(value.size)
        buf.write(value)
    }
} 

fun `zstdCompress`(`data`: kotlin.ByteArray, `level`: kotlin.Int): kotlin.ByteArray {
    return FfiConverterByteArray.lift(
    rustCall { _status: RustCallStatus ->
    UniFFILib.uniffi_compression_fn_func_zstd_compress(FfiConverterByteArray.lower(`data`), FfiConverterInt.lower(`level`), _status)
})
}

 

fun `zstdDecompress`(`data`: kotlin.ByteArray): kotlin.ByteArray {
    return FfiConverterByteArray.lift(
    rustCall { _status: RustCallStatus ->
    UniFFILib.uniffi_compression_fn_func_zstd_decompress(FfiConverterByteArray.lower(`data`), _status)
})
}



